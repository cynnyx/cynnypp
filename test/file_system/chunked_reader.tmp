#include <iostream>
#include <boost/filesystem/operations.hpp>
#include "../../../src/components/file_system/fs_manager_interface.h"
#include "../../../src/utils/type_definitions.h"
#include "../../../src/servicelocator/service_locator.h"
#include "catch.hpp"


using namespace atlas;
const std::string input_dir = "../test/components/file_system/data";
boost::asio::io_service::work *w;
components::TimerManager::TimerId t;
inline void createKeepAlive() {
    w = new boost::asio::io_service::work(ServiceLocator::getIoService());
    t = ServiceLocator::getTimerManager().scheduleCallback([](){ delete w;}, std::chrono::milliseconds(10000));
};

inline void deleteKeepAlive() {
    delete w;
    ServiceLocator::getTimerManager().deleteTimer(t);
}
SCENARIO("Opening a file with size less than a chunk", "[fs][fs_chunked]"){

    auto chunkedReader = ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/multiplea", 1024);
    auto &io = ServiceLocator::getIoService();
    //io.reset();
    createKeepAlive();
    io.reset();
    chunkedReader->next_chunk([](components::filesystem::ErrorCode ec, Buffer b){
        REQUIRE(ec == components::filesystem::ErrorCode::end_of_file);
        std::string s1 = "aaaaaaaaaaaaaaaaaaaa\n";
        Buffer r1;
        r1.insert(r1.begin(), s1.begin() + 16, s1.end());
        REQUIRE(b == r1);
        deleteKeepAlive();
    });
    io.run();
}

SCENARIO("Opening a file with chunk size equal to 0", "[fs][fs_chunked]"){
    REQUIRE_THROWS(ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/multiplea", 0));
    auto &io = ServiceLocator::getIoService();
    io.reset();
    io.run();
}

SCENARIO("Opening a file with size multiple of a page", "[fs][fs_chunked]") {
    auto chunkedReader = ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/chunkedmultiple.txt", 4096);
    auto &io = ServiceLocator::getIoService();
    //io.reset();
    createKeepAlive();
    io.reset();
    unsigned int count = 0;
    std::function<void(components::filesystem::ErrorCode, Buffer b)> readCallback;
    Buffer ciao;
    readCallback = [&count, chunkedReader, &readCallback, &ciao](components::filesystem::ErrorCode ec, Buffer b) {
        count++;
        bool allA = true;

        ciao.insert(ciao.end(), b.begin(), b.end());
        //REQUIRE(b.size() == 4096);
        for (auto i = b.begin(); i != b.end(); ++i) {
            if (*i != 'a') {
                allA = false;
                break;
            }
        }
        REQUIRE(allA == true);
        if(!ec) {

            chunkedReader->next_chunk(readCallback);
        } else {
            deleteKeepAlive();
        }

    };
    chunkedReader->next_chunk(readCallback);

    io.run();

    REQUIRE(ciao.size() == 8192 - 2*sizeof(FileVersion));
}

SCENARIO("Opening a file with size not-multiple of a page but still larger", "[fs][fs_chunked]"){
    auto chunkedReader = ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/chunkedmultiple.txt", 17);
    auto &io = ServiceLocator::getIoService();
    //io.reset();
    createKeepAlive();
    io.reset();
    unsigned int count = 0;
    std::function<void(components::filesystem::ErrorCode, Buffer b)> readCallback;
    Buffer ciao;
    readCallback = [&count, chunkedReader, &readCallback, &ciao](components::filesystem::ErrorCode ec, Buffer b) {
        count++;
        bool allA = true;
        ciao.insert(ciao.end(), b.begin(), b.end());
        REQUIRE(b.size() <= 17);
        for (auto i = b.begin(); i != b.end(); ++i) {
            if (*i != 'a') {
                allA = false;
                break;
            }
        }
        REQUIRE(allA == true);
        if(!ec) {
            chunkedReader->next_chunk(readCallback);
        } else {
            deleteKeepAlive();
        }
    };
    chunkedReader->next_chunk(readCallback);

    io.run();
    REQUIRE(ciao.size() == 8192 - 2*sizeof(FileVersion));
}

SCENARIO("Opening an empty file", "[fs][fs_chunked]") {
    auto chunkedReader = ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/empty");
    auto &io = ServiceLocator::getIoService();
    //io.reset();
    createKeepAlive();
    io.reset();
    unsigned int count = 0;
    std::function<void(components::filesystem::ErrorCode, Buffer b)> readCallback;
    readCallback = [&count, chunkedReader, &readCallback](components::filesystem::ErrorCode ec, Buffer b) {
        REQUIRE(ec);
        REQUIRE(b.size() == 0);
    };
    chunkedReader->next_chunk(readCallback);
    io.run();
}

SCENARIO("Opening a file that does not exist", "[fs][fs_chunked]"){
    REQUIRE_THROWS(ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/chunkedmughdfauihltiple.txt"));
    auto &io = ServiceLocator::getIoService();
    io.reset();
    io.run();
}


SCENARIO("Never calling the nextChunk function", "[fs][fs_chunked]"){
    auto chunkedReader = ServiceLocator::getFilesystemManager().make_chunked_stream(input_dir+"/read/chunkedmultiple.txt");
    auto &io = ServiceLocator::getIoService();
    io.reset();
    io.run(); //should just exit withour issues.
}
